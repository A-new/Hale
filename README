[1] INSTALL
===========
Hale has the following dependencies:

Python == 2.6
Django == 1.2.1
Twisted == 10.1.0
GeoIP-Python == 1.2.4 (and GeoIP C lib)
Whoosh == 0.3.18
django-haystack == 1.0.1-final
django-piston == 0.2.3rc1
pefile == 1.2.10-63
pyreadline == 1.6.1.dev-r0 (on Windows)
sleekxmpp == 0.2.3.1
wsgiref == 0.1.2
zope.interface == 3.6.1
oauth2 == 1.2.0
httplib2 == 0.6.0

Additionally the monitor requires a database backend driver corresponding to the database used by django. When these libraries are installed download the source from here and extract it anywhere.

[2] SETUP
=========
* First create a database that will be used by Hale, the database engine can be any of your choice like MySQL, PostgreSQL etc.

* Next step is to install python database backend drivers corresponding to the used server engine.

* Edit settings.py in hale/src/webdb/ and set the following configurations in DATABASES: ENGINE, NAME, USER, PASSWORD, HOST, PORT where the engine setting is for example django.db.backends.mysql if your server engine is MySQL. The name setting is the name of your database used when creating it.

* In the webdb directory run the following command: python manage.py syncdb. If you get any errors here it’s most likely that the database settings in settings.py are incorrect. Also set the superuser that will be used when administrating the users.

* Run python manage.py rebuild_index to let the search engine index first time. This search engine is used by the web ui to find queries.

* Run python manage.py runserver and head to http://127.0.0.1:8000 to check if setup was correctly done. Then go to to http://127.0.0.1/admin and login with your superuser account created before. Create some users if you wish so and then add your proxies. If no proxies are specified then the monitor will connect directly to the botnet.

* The runserver command deploys a development server that is not recommended to use public since performance issues arise. Instead deploy the web ui with a web server of your choice. TODO deploying

* Before running the monitor edit hale.conf in hale/src/conf/ if you wish to use a XMPP server. If not then skip this step. To activate XMPP bot either edit login info to an existing account and server or start your own XMPP server. An important step when starting up a XMPP server is to increase the max stanza size from the default value to something like 10Mb. Otherwise malware sharing will not be possible. The channel settings in hale.conf are used for setting the share grouproom used by the bot and the coord setting is used for the grouproom where all coordination between sensors are done.

[3] USAGE
=========


To start the monitor head to hale/src/ and execute python main.py. If it fires up with errors then the django settings.py file is not correctly set or some libraries are missing. When the monitor is running type help or ? to get the available commands. Type help command to get more info about the specific command. Starting up a monitor bot is done by first editing the hale/src/conf/modules.conf file, for example using a irc configuration as follow:

[ircConf] module = irc botnet = irc.freenode.net port = 6667 password = None nick = testjg5534 username = agent007 realname = Spying channel = #testasdf channel_pass = kluczbork pass_grammar = PASS nick_grammar = NICK user_grammar = USER join_grammar = JOIN version_grammar = VERSION time_grammar = TIME privmsg_grammar = PRIVMSG topic_grammar = TOPIC currenttopic_grammar = 332 ping_grammar = PING pong_grammar = PONG

Edit or create a new config by specifying a new uniquely named section ([ircConf] part). At the top of the conf file there is a section called uniqueKeys where all unique fields for a module are specified and used to generate the botnet hash, this should usually not be changed to preserve correct botnet tracking. When this is done run useconf section to load the configuration and then fire up the bot with exec modulename id where id is set by you to identify the botnet.


[4] DEV
=======
How to add modules, the current module API work as follow:

1) Implement module, for example:

import moduleManager
from utils import moduleInterface

@moduleManager.register("irc")
def module_setup(config, hash):
    """
    Function to register modules, simply
    implement this to pass along the config
    to the module object and return it back
    """
    
    return IRC(config, hash)

# must inherit from Module class
class IRC(moduleInterface.Module):

   def __init__(self, config, hash):
       self.config = config
       self.hash = hash
   
   # must be implemented
   def stop(self):
       # stop execution
   
   # must be implemented
   def run(self):
       # start execution
   
   # must be implemented    
   def getConfig(self):
       return self.config

Add decorator for the register function (in this case module_setup) which will be called with the current configuration as argument and the config hash made of the unique keys. This function can be named anything. Pass along the configurations to the module object, the configHandler catches KeyErrors so if wrong configurations are sent to this function configHandler will notify you about it. 

Also follow the naming convention nameModule.py and @moduleManager.register("name") and import the moduleManager, if not the moduleManager will notify you about any errors.

Catch all possible exceptions and send them to the module coordinator error bucket which takes care of all errors from every module running in the monitor system. These errors can be shown with the 'showlog' command in the CLI.

2) Drag the file to the modules directory. The moduleManager will then automatically import it and check for errors.

3) In modules.conf edit the configuration, in this case:

# specify unique configs for module
# a * means that all configs contaning the strings equal to the one 
# after the * will be treated as unique. 
# in this example all pass_grammar, mode_grammar etc should be 
# treated as unique keys
[uniqueKeys]
irc = botnet, *grammar, ... etc
# name a section, can be anything as long as its unique
# and add module regname (in this case irc) as module option
[myIrcConf]
module = irc
nick = SpyBot
channel = #irc
...
etc.

Feeder bot HOWTO:

When sending a request for a botnet to track the request is made as follow
to the groupchat coordination room 

sensorLoadReq

where all sensors reply with their id and queue length (number of monitored botnets)

sensorLoadAck id=353f6650859547ed06597dbfa1dcfd88 queue=0

The feeder then choose one sensor based on this info like lowest queue length
and if these are equal for several sensors, then the sensor id sorted alphabetically
with lowest value is chosen.

When the feeder has chosen a sensor it sends a private chat message to the sensor

startTrackReq config

where config is a string representation of the configuration, for example

module=irc botnet=irc.freenode.net etc..

The sensor then replies with with an acknowledgement together with the config hash
which can be used to distringuish the botnet logs from the other logs in the share channel
Example of acknowledgment:

startTrackAck hash

if no one else is monitoring this botnet, otherwise a startTrackNack is received if the 
botnet is already monitored or the sensor does not have the module installed for this botnet

RESTful Web API:

To get access to the api you need a consumer key and secret key, this can be created by the admin and are used with OAuth to authenticate. The following URLs are available to fetch data in JSON format:

    /api/botnet will reply with all botnets monitored
    /api/botnet/botnethash will reply with the botnet with hash equal to botnethash
    /api/host/hostname will reply with all botnets monitored with host equal to hostname
    /api/type/module will reply with all botnets monitored with the module
    /api/botips/hash will reply with all ips captured by botnet with the value hash
    /api/bologs/hash will reply with all logs for botnet with value hash
    /api/bofiles/hash will reply with file hashes caputed by botnet with value hash
    /api/file/hash returns botnet(s) info for those that have captured file with the hash specified
    /api/ip/addr will reply with botnet(s) info for those that have detected an IP with number addr
    
Note that currently only GET operations are possible.
